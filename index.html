<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verdant Siege - Survival Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        #hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
        }
        #wave-info {
            text-align: right;
        }
        #wave-display {
            font-size: 32px;
            color: #ff3333;
            font-weight: bold;
        }
        #ammo-display {
            color: #ffcc00;
            font-size: 32px;
            font-weight: bold;
        }
        #gun-name {
            font-size: 18px;
            color: #aaaaaa;
            margin-top: 5px;
        }
        
        /* Bottom HUD Container */
        #hud-bottom {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-start;
        }

        #stamina-container {
            position: relative;
            width: 200px;
            height: 15px;
            background-color: #333;
            border: 1px solid white;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #stamina-bar {
            width: 100%;
            height: 100%;
            background-color: #00ccff;
        }

        #health-container {
            position: relative;
            width: 300px;
            height: 30px;
            background-color: #333;
            border: 2px solid white;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #00ff00;
            transition: width 0.1s linear, background-color 0.2s;
        }
        #health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 1px 1px 0 #000;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background-color: transparent;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: opacity 0.2s;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 2px;
            background-color: red;
            transform: translate(-50%, -50%);
        }
        #reload-msg {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            font-weight: bold;
            display: none;
            text-shadow: 1px 1px 2px black;
        }
        #wave-clear-msg {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 40px;
            font-weight: bold;
            display: none;
            text-shadow: 0 0 10px #004400;
            text-align: center;
        }
        
        /* Menu System */
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 10;
            pointer-events: auto;
        }
        
        .menu-screen {
            text-align: center;
            display: none; /* Controlled by JS */
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .game-title {
            font-size: 60px;
            font-weight: bold;
            color: #2E8B57;
            text-shadow: 0 0 10px #000;
            margin-bottom: 10px;
            letter-spacing: 5px;
        }

        .menu-btn {
            padding: 15px 40px;
            font-size: 24px;
            background: rgba(0,0,0,0.6);
            border: 2px solid #fff;
            color: #fff;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
            min-width: 200px;
        }
        .menu-btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
        }
        
        .diff-container {
            display: flex;
            gap: 20px;
        }
        
        .diff-btn {
            font-size: 18px;
            min-width: 150px;
        }

        .diff-btn[data-diff="easy"]:hover { border-color: #00ff00; color: #00ff00; background: black; }
        .diff-btn[data-diff="moderate"]:hover { border-color: #ffff00; color: #ffff00; background: black; }
        .diff-btn[data-diff="hard"]:hover { border-color: #ff0000; color: #ff0000; background: black; }

        #pause-text {
            font-size: 48px;
            letter-spacing: 10px;
            margin-bottom: 20px;
        }

        #game-over {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.95);
            color: red;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            font-weight: bold;
            z-index: 20;
            pointer-events: auto;
            text-shadow: 0 0 10px black;
        }
        
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.6) 100%);
            opacity: 0;
            transition: opacity 0.1s;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>

    <div id="game-over">
        YOU DIED
        <button class="menu-btn" id="restart-btn">RETURN TO MENU</button>
    </div>

    <div id="ui-layer">
        <div id="hud-top">
            <div>
                <div id="score-display">KILLS: 0</div>
                <div id="ammo-display">30 / 0</div>
                <div id="gun-name">Pistol</div>
            </div>
            <div id="wave-info">
                <div>WAVE</div>
                <div id="wave-display">1</div>
                <div id="enemies-left" style="font-size: 16px; color: #ccc;">Enemies: 0</div>
            </div>
        </div>
        
        <div id="reload-msg">RELOADING...</div>
        <div id="wave-clear-msg">WAVE COMPLETE<br><span style="font-size:20px; color:white;">Next Wave in 3s...</span></div>

        <div id="hud-bottom">
            <div id="stamina-container">
                <div id="stamina-bar"></div>
            </div>
            <div id="health-container">
                <div id="health-bar"></div>
                <div id="health-text">100</div>
            </div>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="blocker">
        <!-- Main Menu -->
        <div id="menu-main" class="menu-screen" style="display: flex;">
            <div class="game-title">VERDANT SIEGE</div>
            <button id="btn-play" class="menu-btn">PLAY</button>
        </div>

        <!-- Difficulty Selection -->
        <div id="menu-diff" class="menu-screen">
            <h2>SELECT DIFFICULTY</h2>
            <div class="diff-container">
                <button class="menu-btn diff-btn" data-diff="easy">EASY</button>
                <button class="menu-btn diff-btn" data-diff="moderate">MODERATE</button>
                <button class="menu-btn diff-btn" data-diff="hard">HARD</button>
            </div>
            <br>
            <button id="btn-back" class="menu-btn" style="font-size: 16px; min-width: 100px;">BACK</button>
        </div>

        <!-- Pause Screen -->
        <div id="menu-pause" class="menu-screen">
            <div id="pause-text">PAUSED</div>
            <div style="font-size: 14px; color: #aaa;">Click anywhere to resume</div>
        </div>
    </div>

    <!-- Import Three.js from CDN (r128 Stable) -->
    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        // --- Configuration ---
        const MOVEMENT_SPEED = 10.0;
        const SPRINT_SPEED = 18.0;
        
        // Mutable Difficulty Stats (Defaults)
        let MAX_STAMINA = 100;
        let STAMINA_DRAIN = 30; // Per second
        let STAMINA_REGEN = 15; // Per second
        let ENEMY_BASE_SPEED = 6.5;
        let ENEMY_HEALTH_MULT = 1.0;
        let ENEMY_DAMAGE_MULT = 1.0;

        const BOSS_SPEED_MULT = 0.8; 
        const MAP_SIZE = 400;
        const TREE_COUNT = 300;
        const AMMO_PER_BOX = 10;
        const RELOAD_TIME = 1500;
        const PLAYER_RADIUS = 0.5;
        const MOUNTAIN_HEIGHT_LIMIT = 0.5; 

        // Difficulty Settings (Default Moderate)
        let difficultySettings = {
            ammoSpawnInterval: 5000,
            healthSpawnInterval: 15000,
            initialAmmo: 10,
            initialHealth: 4
        };
        
        // --- Gun Stats Per Wave ---
        const GUN_STATS = [
            { name: "M1911 Pistol", auto: false, rate: 0.0, damage: 1, color: 0x333333, clip: 12 },    // Wave 1
            { name: "Magnum",       auto: false, rate: 0.0, damage: 3, color: 0x888888, clip: 6 },     // Wave 2
            { name: "MP5 SMG",      auto: true,  rate: 0.1, damage: 1, color: 0x3333aa, clip: 30 },    // Wave 3
            { name: "UMP-45",       auto: true,  rate: 0.12,damage: 2, color: 0x444444, clip: 25 },    // Wave 4
            { name: "P90",          auto: true,  rate: 0.08,damage: 1, color: 0x4444cc, clip: 50 },    // Wave 5
            { name: "AK-47",        auto: true,  rate: 0.15,damage: 3, color: 0x8B4513, clip: 30 },    // Wave 6
            { name: "M4A1",         auto: true,  rate: 0.12,damage: 3, color: 0x222222, clip: 30 },    // Wave 7
            { name: "Combat Rifle", auto: true,  rate: 0.12,damage: 4, color: 0x228822, clip: 20 },    // Wave 8
            { name: "DMR Sniper",   auto: false, rate: 0.2, damage: 10,color: 0x556B2F, clip: 10 },    // Wave 9
            { name: "Barrett .50",  auto: false, rate: 1.0, damage: 50,color: 0x000000, clip: 5 }      // Wave 10
        ];

        // --- State ---
        let camera, scene, renderer, listener;
        let dirLight, hemiLight, sun; // Global environment vars
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isAiming = false, isSprinting = false, isShooting = false;
        
        // Jumping State
        let canJump = false;
        let verticalVelocity = 0;

        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        
        let enemies = [];
        let ammoBoxes = [];
        let healthSticks = [];
        let birds = [];
        let treeColliders = [];
        
        let score = 0;
        let currentWave = 1;
        let enemiesToSpawn = 0;
        let enemiesAlive = 0;
        let waveInProgress = false;
        
        let stamina = MAX_STAMINA;
        let health = 100;
        
        // Gun State
        let currentGunIdx = 0;
        let clipAmmo = GUN_STATS[0].clip;
        let reserveAmmo = 0; // Starts at 0
        let lastShotTime = 0;
        let isReloading = false;
        
        let isGameActive = false;
        let isDead = false;
        let isInMenu = true;

        let spawnInterval = null;
        let growlInterval = null;
        let ammoSpawnTimeout = null;
        let healthSpawnTimeout = null;
        let lastDamageTime = 0;

        // Sounds
        const sounds = { fire: null, reload: null, growl: null, birds: null, kill: null };

        // UI Elements
        const blocker = document.getElementById('blocker');
        const menuMain = document.getElementById('menu-main');
        const menuDiff = document.getElementById('menu-diff');
        const menuPause = document.getElementById('menu-pause');
        
        const gameOverScreen = document.getElementById('game-over');
        const reloadMsg = document.getElementById('reload-msg');
        const waveMsg = document.getElementById('wave-clear-msg');
        const staminaContainer = document.getElementById('stamina-container');
        
        const raycaster = new THREE.Raycaster();
        
        const colors = {
            sky: 0x87CEEB,
            ground: 0x2E8B57, // SeaGreen
            treeTrunk: 0x3d2e23,
            treeLeaves: 0x1E5924,
            enemy: 0x2c3e50, 
            boss: 0x8B0000,
            ammo: 0x00FF00,
            health: 0xFF0000, 
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xFFD700); // Start Sunrise
            scene.fog = new THREE.Fog(0xFFD700, 20, 150); // Light fog for atmosphere

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2; 
            camera.rotation.order = 'YXZ';
            scene.add(camera);

            listener = new THREE.AudioListener();
            camera.add(listener);
            loadSounds();

            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 200, 0);
            scene.add(hemiLight);

            // --- SUN & SHADOWS ---
            dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(-200, 0, 50); // Start at Horizon (East)
            dirLight.castShadow = true;
            
            // Critical: Expand shadow camera to cover the whole map
            const d = 250; 
            dirLight.shadow.camera.left = -d;
            dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d;
            dirLight.shadow.camera.bottom = -d;
            
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.bias = -0.0005; // Fix shadow artifacts
            scene.add(dirLight);

            // Visual Sun Mesh
            const sunGeo = new THREE.SphereGeometry(15, 32, 32);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffff00 }); 
            sun = new THREE.Mesh(sunGeo, sunMat);
            sun.position.copy(dirLight.position);
            scene.add(sun);
            
            createClouds();
            createGround();
            generateForest();
            generateRocks(); 
            generateBirds();
            
            // Show preview gun
            createGun(0, GUN_STATS[0].color);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding; 
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
            
            setupMenuSystem();
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.getElementById('restart-btn').addEventListener('click', returnToMenu);
        }

        function createClouds() {
            const cloudGeo = new THREE.DodecahedronGeometry(15, 0);
            const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });

            for (let i = 0; i < 40; i++) {
                const cloud = new THREE.Group();
                const parts = 3 + Math.floor(Math.random() * 3);
                for(let j=0; j<parts; j++) {
                    const mesh = new THREE.Mesh(cloudGeo, cloudMat);
                    mesh.position.set(
                        (Math.random()-0.5)*20,
                        (Math.random()-0.5)*10,
                        (Math.random()-0.5)*20
                    );
                    mesh.scale.setScalar(0.5 + Math.random());
                    cloud.add(mesh);
                }
                
                cloud.position.set(
                    (Math.random()-0.5) * 800,
                    80 + Math.random() * 50,
                    (Math.random()-0.5) * 800
                );
                scene.add(cloud);
            }
        }

        function setupMenuSystem() {
            document.getElementById('btn-play').addEventListener('click', () => {
                menuMain.style.display = 'none';
                menuDiff.style.display = 'flex';
            });

            document.getElementById('btn-back').addEventListener('click', () => {
                menuDiff.style.display = 'none';
                menuMain.style.display = 'flex';
            });

            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const diff = e.target.getAttribute('data-diff');
                    startGame(diff);
                });
            });
            
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === document.body) {
                    isGameActive = true;
                    if (!isInMenu) {
                        blocker.style.display = 'none';
                        menuPause.style.display = 'none';
                    }
                } else {
                    if (!isInMenu && !isDead) {
                        isGameActive = false;
                        blocker.style.display = 'flex';
                        menuMain.style.display = 'none';
                        menuDiff.style.display = 'none';
                        menuPause.style.display = 'flex'; 
                    }
                }
            });
            
            menuPause.addEventListener('click', () => {
                if(!isDead && !isInMenu) document.body.requestPointerLock();
            });
        }

        function startGame(difficulty) {
            // Apply Difficulty Scalings
            if(difficulty === 'hard') {
                difficultySettings = { ammoSpawnInterval: 25000, healthSpawnInterval: 40000, initialAmmo: 2, initialHealth: 1 };
                MAX_STAMINA = 70;
                STAMINA_DRAIN = 45;
                STAMINA_REGEN = 8;
                ENEMY_BASE_SPEED = 11.5; // Reduced from 13.0 to 11.5 (Matches Moderate)
                ENEMY_HEALTH_MULT = 3.0;
                ENEMY_DAMAGE_MULT = 2.5;
            } 
            else if (difficulty === 'moderate') {
                difficultySettings = { ammoSpawnInterval: 6000, healthSpawnInterval: 20000, initialAmmo: 8, initialHealth: 3 };
                MAX_STAMINA = 90;
                STAMINA_DRAIN = 35;
                STAMINA_REGEN = 12;
                ENEMY_BASE_SPEED = 11.5; // Slightly faster than Walk (10.0)
                ENEMY_HEALTH_MULT = 1.5;
                ENEMY_DAMAGE_MULT = 1.5;
            } 
            else {
                difficultySettings = { ammoSpawnInterval: 3000, healthSpawnInterval: 10000, initialAmmo: 15, initialHealth: 6 };
                MAX_STAMINA = 100;
                STAMINA_DRAIN = 30;
                STAMINA_REGEN = 15;
                ENEMY_BASE_SPEED = 10.0; // Same as Walk (10.0)
                ENEMY_HEALTH_MULT = 1.0;
                ENEMY_DAMAGE_MULT = 0.8;
            }

            // Reset Game State
            isInMenu = false;
            isDead = false;
            health = 100;
            stamina = MAX_STAMINA;
            score = 0;
            currentWave = 1;
            
            // Clear old items
            enemies.forEach(e => scene.remove(e)); enemies = [];
            ammoBoxes.forEach(b => scene.remove(b)); ammoBoxes = [];
            healthSticks.forEach(h => scene.remove(h)); healthSticks = [];
            
            // Spawn items
            for(let i=0; i<difficultySettings.initialAmmo; i++) spawnAmmoBox();
            for(let i=0; i<difficultySettings.initialHealth; i++) spawnHealthStick();
            
            // Setup Gun - INITIAL LOAD ONLY
            currentGunIdx = 0;
            createGun(0, GUN_STATS[0].color);
            clipAmmo = GUN_STATS[0].clip; // Give full clip for first wave only
            reserveAmmo = 0;
            
            updateHUD();
            updateHealthUI();
            
            // Start Locks & Audio
            document.body.requestPointerLock();
            if (listener.context && listener.context.state === 'suspended') listener.context.resume();
            if (sounds.birds && !sounds.birds.isPlaying) sounds.birds.play();
            
            // Start Loops
            startWave(1);
            growlInterval = setInterval(() => { if(Math.random()>0.7 && isGameActive) playSound('growl'); }, 5000);
            
            scheduleNextAmmo();
            scheduleNextHealth();
            
            // Force reset sun to morning
            updateDayNightCycle(true);
        }

        function scheduleNextAmmo() {
            if(ammoSpawnTimeout) clearTimeout(ammoSpawnTimeout);
            ammoSpawnTimeout = setTimeout(() => {
                if(isGameActive) spawnAmmoBox();
                scheduleNextAmmo();
            }, difficultySettings.ammoSpawnInterval);
        }

        function scheduleNextHealth() {
            if(healthSpawnTimeout) clearTimeout(healthSpawnTimeout);
            healthSpawnTimeout = setTimeout(() => {
                if(isGameActive) spawnHealthStick();
                scheduleNextHealth();
            }, difficultySettings.healthSpawnInterval);
        }

        // --- Audio (Synth) ---
        function generateSynthSound(name) {
            if (!listener.context) return null; 
            const ctx = listener.context;
            const sampleRate = ctx.sampleRate;
            let duration = 0.5;
            if(name === 'fire') duration = 0.1;
            if(name === 'reload') duration = 0.8;
            if(name === 'growl') duration = 1.0;
            if(name === 'kill') duration = 0.2;
            if(name === 'birds') duration = 2.0;

            const buffer = ctx.createBuffer(1, sampleRate * duration, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < buffer.length; i++) {
                const t = i / sampleRate;
                if (name === 'fire') data[i] = (Math.random() * 2 - 1) * Math.exp(-20 * t);
                else if (name === 'reload') data[i] = Math.sin(2 * Math.PI * (400 + 400 * t) * t) * 0.5;
                else if (name === 'growl') data[i] = (Math.random() * 0.5 + Math.sin(2 * Math.PI * 50 * t)) * Math.exp(-3 * t);
                else if (name === 'kill') data[i] = (Math.random() * 2 - 1) * Math.exp(-20 * t) * Math.sin(2 * Math.PI * 100 * t);
                else if (name === 'birds') data[i] = (t % 0.5 < 0.1) ? Math.sin(2 * Math.PI * 2000 * t) * 0.1 : 0;
            }
            return buffer;
        }

        function loadSounds() {
            const audioLoader = new THREE.AudioLoader();
            const initSound = (name, path, loop, volume) => {
                if (!listener.context) return;
                const sound = new THREE.Audio(listener);
                const synthBuffer = generateSynthSound(name);
                if (synthBuffer) sound.setBuffer(synthBuffer);
                sound.setLoop(loop);
                sound.setVolume(volume);
                sounds[name] = sound;
            };
            initSound('fire', 'fire.mp3', false, 0.4);
            initSound('reload', 'reload.mp3', false, 0.5);
            initSound('growl', 'enemygrowl.mp3', false, 0.6);
            initSound('birds', 'birds.mp3', true, 0.15); 
            initSound('kill', 'kill.mp3', false, 0.6);
        }

        // --- Environment ---
        function getElevation(x, z) {
            return 0; // Flat
        }

        function createGround() {
            const groundGeo = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE, 128, 128);
            const groundMat = new THREE.MeshStandardMaterial({ color: colors.ground, roughness: 1.0, flatShading: true });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = "ground";
            scene.add(ground);
        }

        function generateForest() {
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.5, 2.5, 7);
            const trunkMat = new THREE.MeshStandardMaterial({ color: colors.treeTrunk });
            const leavesBotGeo = new THREE.ConeGeometry(2.5, 3.5, 7);
            const leavesTopGeo = new THREE.CylinderGeometry(0.1, 2.0, 4.0, 7); 
            const treeMat = new THREE.MeshStandardMaterial({ color: colors.treeLeaves, flatShading: true });
            const minTreeDistance = 15; 

            for (let i = 0; i < TREE_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2;
                // Trees start at radius 20, keeping spawn clear
                const radius = 20 + Math.random() * (MAP_SIZE/2 - 30);
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                let tooClose = false;
                for (let tree of treeColliders) {
                    const dx = x - tree.x;
                    const dz = z - tree.z;
                    if (dx*dx + dz*dz < minTreeDistance * minTreeDistance) {
                        tooClose = true;
                        break;
                    }
                }
                if (tooClose) continue;

                const scale = 0.8 + Math.random() * 1.5; 
                treeColliders.push({ x: x, z: z, radius: 0.8 * scale });

                const group = new THREE.Group();
                group.position.set(x, 0, z);
                group.scale.set(scale, scale, scale);
                group.userData.isObstacle = true;

                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 1.25;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                group.add(trunk);
                
                const leavesBot = new THREE.Mesh(leavesBotGeo, treeMat);
                leavesBot.position.y = 2.5;
                leavesBot.castShadow = true;
                group.add(leavesBot);

                const leavesTop = new THREE.Mesh(leavesTopGeo, treeMat);
                leavesTop.position.y = 4.5;
                leavesTop.castShadow = true;
                group.add(leavesTop);
                
                group.rotation.y = Math.random() * Math.PI;
                scene.add(group);
            }
        }

        function generateRocks() {
            const rockGeoSmall = new THREE.DodecahedronGeometry(0.5, 0);
            const rockGeoLarge = new THREE.DodecahedronGeometry(1.2, 0);
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9, flatShading: true });

            for (let i = 0; i < 150; i++) {
                const geo = Math.random() > 0.5 ? rockGeoSmall : rockGeoLarge;
                const rock = new THREE.Mesh(geo, rockMat);
                
                const angle = Math.random() * Math.PI * 2;
                // FIX: Enforce minimum radius of 15 to keep spawn clear
                const radius = 15 + Math.random() * (MAP_SIZE/2 - 25);
                rock.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                
                rock.position.y = -0.2 + Math.random() * 0.3;
                
                rock.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                rock.scale.set(0.8+Math.random(), 0.8+Math.random(), 0.8+Math.random());
                
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
                
                if (geo === rockGeoLarge) {
                    treeColliders.push({ x: rock.position.x, z: rock.position.z, radius: 1.0 });
                }
            }
        }

        function generateBirds() {
            const birdGeo = new THREE.BufferGeometry();
            const vertices = new Float32Array([0.5, 0, 0.2, -0.5, 0, 0.2, 0, 0, -0.3]);
            birdGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            const birdMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
            for(let i=0; i<15; i++) {
                const bird = new THREE.Mesh(birdGeo, birdMat);
                bird.position.set((Math.random()-0.5)*100, 30 + Math.random()*20, (Math.random()-0.5)*100);
                bird.userData = { speed: 0.2 + Math.random() * 0.2, angle: Math.random() * Math.PI * 2 };
                birds.push(bird);
                scene.add(bird);
            }
        }

        // --- NEW HELPER FOR SPAWN SAFETY ---
        function isPositionValid(x, z) {
            for (let tree of treeColliders) {
                // Buffer of 1.5 units (tree radius + safety margin)
                const minDist = tree.radius + 1.5;
                const dx = x - tree.x;
                const dz = z - tree.z;
                if (dx * dx + dz * dz < minDist * minDist) {
                    return false;
                }
            }
            return true;
        }

        function spawnAmmoBox() {
            if(ammoBoxes.length > 30) return; // limit count
            
            const group = new THREE.Group();
            
            // --- Materials ---
            const boxColor = 0x4b5320; // Olive Drab / Army Green
            const detailColor = 0x1a1a1a; // Dark Grey metal
            const labelColor = 0xffd700; // Gold/Yellow text
            
            const boxMat = new THREE.MeshStandardMaterial({ 
                color: boxColor, 
                roughness: 0.7,
                emissive: 0x111b11, // Slight glow to be visible at night
                emissiveIntensity: 0.2
            });
            const detailMat = new THREE.MeshStandardMaterial({ color: detailColor, roughness: 0.4, metalness: 0.6 });
            const labelMat = new THREE.MeshBasicMaterial({ color: labelColor });

            // --- Geometry Construction ---
            const width = 0.7;
            const height = 0.4;
            const depth = 0.35;
            const bodyGeo = new THREE.BoxGeometry(width, height, depth);
            const body = new THREE.Mesh(bodyGeo, boxMat);
            group.add(body);
            
            const lidGeo = new THREE.BoxGeometry(width + 0.04, 0.08, depth + 0.04);
            const lid = new THREE.Mesh(lidGeo, boxMat);
            lid.position.y = height / 2; 
            group.add(lid);
            
            const handleGeo = new THREE.BoxGeometry(0.05, 0.15, 0.15);
            const handleLeft = new THREE.Mesh(handleGeo, detailMat);
            handleLeft.position.set(-(width/2 + 0.02), 0, 0);
            group.add(handleLeft);
            const handleRight = new THREE.Mesh(handleGeo, detailMat);
            handleRight.position.set((width/2 + 0.02), 0, 0);
            group.add(handleRight);
            
            const latchGeo = new THREE.BoxGeometry(0.1, 0.15, 0.04);
            const latch = new THREE.Mesh(latchGeo, detailMat);
            latch.position.set(0, 0.1, depth/2); 
            group.add(latch);
            
            const labelGeo = new THREE.PlaneGeometry(0.25, 0.08);
            const label = new THREE.Mesh(labelGeo, labelMat);
            label.position.set(0, -0.05, depth/2 + 0.01); 
            group.add(label);
            
            const cornerGeo = new THREE.BoxGeometry(0.04, height, 0.04);
            const offsets = [-1, 1];
            offsets.forEach(xDir => {
                offsets.forEach(zDir => {
                    const corner = new THREE.Mesh(cornerGeo, detailMat);
                    corner.position.set(xDir * (width/2), 0, zDir * (depth/2));
                    group.add(corner);
                });
            });

            // --- Positioning ---
            let x, z, attempts = 0;
            do {
                const angle = Math.random() * Math.PI * 2;
                const dist = 30 + Math.random() * 60;
                x = camera.position.x + Math.cos(angle)*dist;
                z = camera.position.z + Math.sin(angle)*dist;
                if(Math.abs(x) > MAP_SIZE/2 || Math.abs(z) > MAP_SIZE/2) { x = 0; z = 10; }
                attempts++;
            } while (!isPositionValid(x, z) && attempts < 10);
            
            group.position.set(x, 0.5, z); 
            group.rotation.y = Math.random() * Math.PI * 2;
            
            group.traverse((obj) => {
                if (obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });
            
            scene.add(group);
            ammoBoxes.push(group);
        }

        function spawnHealthStick() {
            if(healthSticks.length > 20) return;
            const stickGroup = new THREE.Group();
            stickGroup.scale.set(3, 3, 3);
            
            const wrapperGeo = new THREE.BoxGeometry(0.15, 0.05, 0.4);
            const wrapperMat = new THREE.MeshStandardMaterial({ color: 0xEEEEEE }); 
            const wrapper = new THREE.Mesh(wrapperGeo, wrapperMat);
            stickGroup.add(wrapper);
            const labelGeo = new THREE.BoxGeometry(0.16, 0.06, 0.15);
            const labelMat = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
            const label = new THREE.Mesh(labelGeo, labelMat);
            stickGroup.add(label);

            let x, z, attempts = 0;
            do {
                const angle = Math.random() * Math.PI * 2;
                const dist = 40 + Math.random() * 60;
                x = camera.position.x + Math.cos(angle)*dist;
                z = camera.position.z + Math.sin(angle)*dist;
                if(Math.abs(x) > MAP_SIZE/2) { x = 0; z = 15; }
                attempts++;
            } while(!isPositionValid(x, z) && attempts < 10);

            stickGroup.position.set(x, 1.5, z);
            scene.add(stickGroup);
            healthSticks.push(stickGroup);
        }

        function createGun(index, color) {
            if (camera.userData.gun) {
                camera.remove(camera.userData.gun);
            }
            const gunGroup = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.8 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const detailMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5, metalness: 0.9 });

            function addPart(geo, material, x, y, z, rx=0, ry=0, rz=0) {
                const mesh = new THREE.Mesh(geo, material);
                mesh.position.set(x, y, z);
                mesh.rotation.set(rx, ry, rz);
                gunGroup.add(mesh);
            }

            if (index < 2) { 
                addPart(new THREE.BoxGeometry(0.1, 0.15, 0.4), mat, 0, 0.05, 0); 
                addPart(new THREE.BoxGeometry(0.08, 0.25, 0.12), mat, 0, -0.15, 0.1, 0.3); 
                addPart(new THREE.CylinderGeometry(0.02, 0.02, 0.05), darkMat, 0, 0.05, -0.22, Math.PI/2);
                addPart(new THREE.BoxGeometry(0.02, 0.02, 0.02), detailMat, 0, 0.13, 0.18); 
                addPart(new THREE.BoxGeometry(0.02, 0.03, 0.02), detailMat, 0, 0.135, -0.18); 
                addPart(new THREE.TorusGeometry(0.06, 0.01, 8, 16, Math.PI), detailMat, 0, -0.05, 0.05, Math.PI/2, 0, 0); 
            } 
            else if (index < 5) { 
                addPart(new THREE.BoxGeometry(0.12, 0.15, 0.5), mat, 0, 0.05, 0); 
                addPart(new THREE.BoxGeometry(0.08, 0.25, 0.12), mat, 0, -0.15, 0.15, 0.1); 
                addPart(new THREE.CylinderGeometry(0.03, 0.03, 0.2), darkMat, 0, 0.05, -0.35, Math.PI/2); 
                addPart(new THREE.BoxGeometry(0.06, 0.2, 0.1), darkMat, 0, -0.1, -0.1);
                addPart(new THREE.CylinderGeometry(0.015, 0.015, 0.08), detailMat, 0.07, 0.08, -0.1, 0, 0, Math.PI/2); 
                addPart(new THREE.BoxGeometry(0.08, 0.03, 0.08), darkMat, 0.065, 0.05, 0.05); 
                addPart(new THREE.BoxGeometry(0.03, 0.03, 0.03), detailMat, 0, 0.13, 0.2); 
                addPart(new THREE.CylinderGeometry(0.03, 0.03, 0.05), detailMat, 0, 0.13, -0.2, Math.PI/2); 
            }
            else { 
                const bodyMat = (index === 5 || index === 8) ? woodMat : mat; 
                addPart(new THREE.BoxGeometry(0.1, 0.12, 0.7), bodyMat, 0, 0.05, 0); 
                addPart(new THREE.BoxGeometry(0.08, 0.25, 0.12), mat, 0, -0.15, 0.25, 0.1); 
                addPart(new THREE.BoxGeometry(0.05, 0.15, 0.2), mat, 0, 0.02, 0.45); 
                addPart(new THREE.CylinderGeometry(0.025, 0.025, 0.5), darkMat, 0, 0.05, -0.6, Math.PI/2); 
                addPart(new THREE.BoxGeometry(0.06, 0.25, 0.12), darkMat, 0, -0.15, 0); 
                addPart(new THREE.BoxGeometry(0.04, 0.06, 0.08), detailMat, 0, 0.08, -0.4); 
                addPart(new THREE.CylinderGeometry(0.01, 0.01, 0.06), detailMat, 0, 0.12, -0.4); 
                if(index >= 8) { 
                    addPart(new THREE.CylinderGeometry(0.03, 0.04, 0.2), darkMat, 0, 0.13, 0.1, Math.PI/2); 
                    addPart(new THREE.CylinderGeometry(0.035, 0.035, 0.05), detailMat, 0, 0.13, 0.2, Math.PI/2); 
                    addPart(new THREE.CylinderGeometry(0.04, 0.04, 0.05), detailMat, 0, 0.13, 0.0, Math.PI/2); 
                } else {
                    addPart(new THREE.BoxGeometry(0.08, 0.02, 0.4), detailMat, 0, 0.12, 0); 
                    addPart(new THREE.BoxGeometry(0.03, 0.04, 0.03), detailMat, 0, 0.14, 0.15); 
                }
                addPart(new THREE.BoxGeometry(0.02, 0.03, 0.02), detailMat, 0.05, -0.05, 0.08); 
            }

            let posX = 0.3;
            let posY = -0.25;
            let posZ = -0.6; 
            if (index >= 5) { posY = -0.3; posX = 0.35; } 

            gunGroup.position.set(posX, posY, posZ);
            camera.add(gunGroup);
            
            camera.userData.gun = gunGroup;
            camera.userData.hipPos = new THREE.Vector3(posX, posY, posZ);
            
            let aimY = -0.165; 
            if (index >= 2 && index < 5) aimY = -0.16; 
            if (index >= 5) aimY = -0.17; 
            
            camera.userData.aimPos = new THREE.Vector3(0, aimY, posZ);
            camera.userData.reloadPos = new THREE.Vector3(posX, -0.6, posZ);
        }

        function startWave(waveNum) {
            currentWave = waveNum;
            enemiesToSpawn = 5 + (waveNum * 2);
            enemiesAlive = enemiesToSpawn;
            waveInProgress = true;
            
            if (currentWave <= GUN_STATS.length) {
                currentGunIdx = currentWave - 1;
                const newStats = GUN_STATS[currentGunIdx];
                createGun(currentGunIdx, newStats.color); 
            }
            
            updateHUD();
            
            let spawned = 0;
            if(spawnInterval) clearInterval(spawnInterval);
            
            spawnInterval = setInterval(() => {
                if (spawned >= enemiesToSpawn) {
                    clearInterval(spawnInterval);
                    return;
                }
                const isBoss = (spawned === enemiesToSpawn - 1); 
                if(isGameActive) {
                    spawnEnemy(isBoss);
                    spawned++;
                }
            }, 1000); 
        }

        function spawnEnemy(isBoss) {
            const enemyGroup = new THREE.Group();
            enemyGroup.userData.isEnemy = true;
            enemyGroup.userData.id = Math.random() * 100; // Unique offset for walking animation
            
            let scale = isBoss ? 2.5 : 1.0;
            // SCALE HEALTH BY DIFFICULTY
            let hp = (isBoss ? 5 : 1) * ENEMY_HEALTH_MULT;
            
            // --- Colors & Materials ---
            const skinColor = isBoss ? 0x8B0000 : 0x2c3e50; 
            const shirtColor = isBoss ? 0x111111 : (Math.random()>0.5 ? 0x550000 : 0x333333); 
            const pantsColor = 0x1a1a1a; 

            enemyGroup.userData.health = hp;
            enemyGroup.userData.isBoss = isBoss;

            const skinMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.9 });
            const shirtMat = new THREE.MeshStandardMaterial({ color: shirtColor, roughness: 1.0 });
            const pantsMat = new THREE.MeshStandardMaterial({ color: pantsColor, roughness: 1.0 });
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            // --- Body Parts ---
            
            // 1. Torso (Shirt)
            const torsoGeo = new THREE.BoxGeometry(0.5, 0.7, 0.3);
            const torso = new THREE.Mesh(torsoGeo, shirtMat);
            torso.position.y = 1.1; // Shifted up to make room for legs
            enemyGroup.add(torso);
            
            // 2. Head (Skin)
            const headGeo = new THREE.BoxGeometry(0.3, 0.35, 0.3);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.y = 1.65;
            enemyGroup.add(head);

            // 3. Arms (Shirt)
            const armGeo = new THREE.BoxGeometry(0.12, 0.7, 0.12);
            
            const lArm = new THREE.Mesh(armGeo, shirtMat);
            lArm.position.set(-0.35, 1.25, 0.2);
            lArm.rotation.x = -Math.PI / 2; // Zombie arms forward
            enemyGroup.add(lArm);

            const rArm = new THREE.Mesh(armGeo, shirtMat);
            rArm.position.set(0.35, 1.25, 0.2);
            rArm.rotation.x = -Math.PI / 2;
            enemyGroup.add(rArm);
            
            // 4. Legs (Pants)
            const legGeo = new THREE.BoxGeometry(0.18, 0.75, 0.2);
            
            // Left Leg
            const lLeg = new THREE.Mesh(legGeo, pantsMat);
            lLeg.position.set(-0.15, 0.375, 0);
            lLeg.name = "leftLeg"; // Important for animation
            
            // Pivot point adjustment for rotation at the hip
            // We wrap it in a group so rotation happens at the top, not center
            const lLegGroup = new THREE.Group();
            lLegGroup.position.set(-0.15, 0.75, 0); // Hip position
            lLeg.position.set(0, -0.375, 0); // Offset geometry
            lLegGroup.add(lLeg);
            lLegGroup.name = "leftLegGroup";
            enemyGroup.add(lLegGroup);

            // Right Leg
            const rLeg = new THREE.Mesh(legGeo, pantsMat);
            rLeg.position.set(0, -0.375, 0);
            
            const rLegGroup = new THREE.Group();
            rLegGroup.position.set(0.15, 0.75, 0); // Hip position
            rLegGroup.add(rLeg);
            rLegGroup.name = "rightLegGroup";
            enemyGroup.add(rLegGroup);

            // 5. Eyes
            const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-0.08, 1.65, 0.16); enemyGroup.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set(0.08, 1.65, 0.16); enemyGroup.add(eyeR);

            enemyGroup.scale.set(scale, scale, scale);

            // --- Spawn Position with Safety Check ---
            let x, z, attempts = 0;
            do {
                const angle = Math.random() * Math.PI * 2;
                const dist = 30 + Math.random() * 20;
                x = camera.position.x + Math.cos(angle) * dist;
                z = camera.position.z + Math.sin(angle) * dist;
                attempts++;
            } while (!isPositionValid(x, z) && attempts < 10);

            enemyGroup.position.set(x, 0, z);

            scene.add(enemyGroup);
            enemies.push(enemyGroup);
        }

        function playSound(name) {
            if (sounds[name] && sounds[name].buffer) {
                if (sounds[name].isPlaying) sounds[name].stop();
                sounds[name].play();
            }
        }

        function onMouseDown(e) {
            if (!isGameActive || isDead || isReloading) return;
            if (e.button === 0) { 
                isShooting = true;
                if (!GUN_STATS[currentGunIdx].auto) tryShoot();
            } else if (e.button === 2) { 
                isAiming = true;
            }
        }

        function onMouseUp(e) {
            if (e.button === 0) isShooting = false;
            if (e.button === 2) isAiming = false;
        }
        
        function tryShoot() {
            if (clipAmmo > 0) {
                shoot();
            } else {
                reload();
            }
        }

        function reload() {
            const stats = GUN_STATS[currentGunIdx];
            if (isReloading || clipAmmo === stats.clip || reserveAmmo === 0) return;
            
            isReloading = true;
            reloadMsg.style.display = 'block';
            playSound('reload');
            
            setTimeout(() => {
                const needed = stats.clip - clipAmmo;
                const take = Math.min(needed, reserveAmmo);
                clipAmmo += take;
                reserveAmmo -= take;
                isReloading = false;
                reloadMsg.style.display = 'none';
                updateHUD();
            }, RELOAD_TIME);
        }

        function shoot() {
            clipAmmo--;
            updateHUD();
            playSound('fire');
            
            const gun = camera.userData.gun;
            if (gun) {
                const kick = isAiming ? 0.02 : 0.1;
                gun.position.z += kick;
                setTimeout(() => { 
                    if(isAiming) gun.position.z = camera.userData.aimPos.z;
                    else gun.position.z -= kick; 
                }, 50);
            }

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            createBulletTrace();

            const damage = GUN_STATS[currentGunIdx].damage;

            for (let i = 0; i < intersects.length; i++) {
                let target = intersects[i].object;
                while(target.parent && target.parent.type !== 'Scene') target = target.parent;
                
                if (target.userData.isEnemy) {
                    target.userData.health -= damage;
                    if (target.userData.health <= 0) {
                        killEnemy(target);
                    } else {
                        target.position.x += (Math.random()-0.5)*0.5;
                    }
                    break; 
                }
                if (target.userData.isObstacle) break; 
                if (!target.isGroup && target.name !== 'ground') break; 
            }
        }
        
        function createBulletTrace() {
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const rightOffset = isAiming ? 0 : 0.2;
            const start = camera.position.clone().add(direction.clone().multiplyScalar(0.5));
            const side = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0,1,0)).normalize();
            start.add(side.multiplyScalar(rightOffset));
            start.y -= 0.2;
            const end = start.clone().add(direction.multiplyScalar(100));
            
            const geom = new THREE.BufferGeometry().setFromPoints([start, end]);
            const mat = new THREE.LineBasicMaterial({ color: 0xffffaa, opacity: 0.8, transparent: true });
            const line = new THREE.Line(geom, mat);
            scene.add(line);
            setTimeout(() => scene.remove(line), 40);
        }

        function killEnemy(enemyGroup) {
            scene.remove(enemyGroup);
            enemies = enemies.filter(e => e !== enemyGroup);
            score++;
            enemiesAlive--;
            playSound('kill');
            updateHUD();

            if (enemiesAlive <= 0 && waveInProgress) {
                waveInProgress = false;
                waveMsg.style.display = 'block';
                setTimeout(() => {
                    waveMsg.style.display = 'none';
                    if (currentWave < GUN_STATS.length) startWave(currentWave + 1);
                }, 3000);
            }
        }

        // --- Controls & Logic ---
        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': case 'ShiftRight': isSprinting = true; break;
                case 'KeyR': reload(); break;
                // --- JUMP LOGIC ---
                case 'Space': 
                    if (canJump) {
                        verticalVelocity = 12.0; 
                        canJump = false;
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': case 'ShiftRight': isSprinting = false; break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateHUD() {
            const stats = GUN_STATS[currentGunIdx];
            document.getElementById('ammo-display').innerText = `${clipAmmo} / ${reserveAmmo}`;
            document.getElementById('score-display').innerText = `KILLS: ${score}`;
            document.getElementById('gun-name').innerText = stats.name;
            document.getElementById('wave-display').innerText = currentWave;
            document.getElementById('enemies-left').innerText = `Enemies: ${enemiesAlive}`;
            
            const ammoEl = document.getElementById('ammo-display');
            ammoEl.style.color = (clipAmmo === 0) ? 'red' : '#ffcc00';
        }

        function updateHealthUI() {
            const bar = document.getElementById('health-bar');
            const txt = document.getElementById('health-text');
            const pct = Math.max(0, health);
            bar.style.width = pct + '%';
            txt.innerText = Math.ceil(pct); 
            if(pct > 50) bar.style.backgroundColor = '#00ff00';
            else if(pct > 25) bar.style.backgroundColor = '#ffff00';
            else bar.style.backgroundColor = '#ff0000';
        }
        
        function takeDamage(amount) {
            const now = performance.now();
            if (now - lastDamageTime < 500) return; 
            health -= amount;
            lastDamageTime = now;
            updateHealthUI();
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.8;
            setTimeout(() => { overlay.style.opacity = 0; }, 200);
            if (health <= 0) die();
        }

        function die() {
            isDead = true;
            isGameActive = false;
            document.exitPointerLock();
            clearInterval(spawnInterval);
            clearInterval(growlInterval);
            if(ammoSpawnTimeout) clearTimeout(ammoSpawnTimeout);
            if(healthSpawnTimeout) clearTimeout(healthSpawnTimeout);
            
            gameOverScreen.style.display = 'flex';
        }

        function returnToMenu() {
            gameOverScreen.style.display = 'none';
            blocker.style.display = 'flex';
            menuMain.style.display = 'flex';
            menuDiff.style.display = 'none';
            menuPause.style.display = 'none';
            isInMenu = true;
            isGameActive = false;
        }

        function checkTreeCollision(pos) {
            for (let tree of treeColliders) {
                const dx = pos.x - tree.x;
                const dz = pos.z - tree.z;
                const minDist = tree.radius + PLAYER_RADIUS;
                if (dx*dx + dz*dz < minDist * minDist) return true;
            }
            return false;
        }

        function updateDayNightCycle(reset = false) {
            let waveFraction = 0;
            if (enemiesToSpawn > 0) {
                waveFraction = 1 - (enemiesAlive / enemiesToSpawn);
            }
            waveFraction = Math.max(0, Math.min(1, waveFraction));
            
            let totalProgress = (currentWave - 1) + waveFraction;
            
            if (reset) totalProgress = 0;
            
            // Map 0 -> 10 to 0 -> 2PI
            const angle = (totalProgress / 10) * (Math.PI * 2); 
            
            const radius = 200;
            const sX = Math.cos(angle) * radius;
            const sY = Math.sin(angle) * radius;
            const sZ = 50; 
            
            // East start
            dirLight.position.set(-sX, sY, sZ); 
            sun.position.copy(dirLight.position);
            
            const intensityFactor = Math.sin(angle);
            const isDay = intensityFactor > -0.2; 
            
            if (isDay) {
                dirLight.intensity = Math.max(0.1, intensityFactor) * 1.2;
                hemiLight.intensity = 0.6;
                sun.visible = true;
            } else {
                dirLight.intensity = 0.1; 
                hemiLight.intensity = 0.1;
                sun.visible = false; 
            }
            
            // Sky Color Interpolation
            const colorSunrise = new THREE.Color(0xFFD700); 
            const colorNoon = new THREE.Color(0x87CEEB);    
            const colorSunset = new THREE.Color(0xFD5E53);  
            const colorNight = new THREE.Color(0x000011);   
            
            let targetColor;
            let normAngle = angle % (2*Math.PI);
            if(normAngle < 0) normAngle += 2*Math.PI;
            
            if (normAngle < Math.PI * 0.5) {
                 const t = normAngle / (Math.PI * 0.5);
                 targetColor = colorSunrise.clone().lerp(colorNoon, t);
            } else if (normAngle < Math.PI) {
                 const t = (normAngle - Math.PI * 0.5) / (Math.PI * 0.5);
                 targetColor = colorNoon.clone().lerp(colorSunset, t);
            } else if (normAngle < Math.PI * 1.5) {
                 const t = (normAngle - Math.PI) / (Math.PI * 0.5);
                 targetColor = colorSunset.clone().lerp(colorNight, t);
            } else {
                 const t = (normAngle - Math.PI * 1.5) / (Math.PI * 0.5);
                 targetColor = colorNight.clone().lerp(colorSunrise, t);
            }
            
            scene.background = targetColor;
            scene.fog.color = targetColor;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isGameActive && !isDead && !isInMenu) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;
                
                updateDayNightCycle(); // Update lighting every frame

                if (isShooting && GUN_STATS[currentGunIdx].auto && !isReloading && clipAmmo > 0) {
                    if (time - lastShotTime > GUN_STATS[currentGunIdx].rate * 1000) {
                        shoot();
                        lastShotTime = time;
                    }
                }

                // Gravity & Jump Physics
                verticalVelocity -= 25.0 * delta; // Gravity
                camera.position.y += verticalVelocity * delta;

                // Floor Collision
                if (camera.position.y < 2.0) {
                    camera.position.y = 2.0;
                    verticalVelocity = 0;
                    canJump = true;
                }

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const moving = moveForward || moveBackward || moveLeft || moveRight;
                let speed = MOVEMENT_SPEED;
                
                // --- FIXED SPRINT LOGIC ---
                if (moving && isSprinting) {
                    if (stamina > 0) {
                        speed = SPRINT_SPEED;
                        stamina = Math.max(0, stamina - STAMINA_DRAIN * delta);
                        staminaContainer.style.opacity = 1;
                    } else {
                        speed = MOVEMENT_SPEED;
                        staminaContainer.style.opacity = 1; 
                    }
                } else {
                    if (stamina < MAX_STAMINA) {
                        stamina = Math.min(MAX_STAMINA, stamina + STAMINA_REGEN * delta);
                        if (stamina >= MAX_STAMINA) staminaContainer.style.opacity = 0;
                        else staminaContainer.style.opacity = 1;
                    }
                }
                
                document.getElementById('stamina-bar').style.width = (stamina / MAX_STAMINA * 100) + '%';

                if (isAiming) speed *= 0.5;

                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
                const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
                const moveVec = new THREE.Vector3();
                if(moveForward) moveVec.add(forward); if(moveBackward) moveVec.sub(forward);
                if(moveRight) moveVec.add(right); if(moveLeft) moveVec.sub(right);
                moveVec.normalize().multiplyScalar(speed * delta);
                
                const potentialPos = camera.position.clone().add(moveVec);
                let canMove = true;
                
                if (checkTreeCollision(potentialPos)) {
                    canMove = false;
                    let slideX = moveVec.clone(); slideX.z = 0;
                    if (!checkTreeCollision(camera.position.clone().add(slideX))) {
                        camera.position.add(slideX);
                    } else {
                        let slideZ = moveVec.clone(); slideZ.x = 0;
                        if (!checkTreeCollision(camera.position.clone().add(slideZ))) {
                            camera.position.add(slideZ);
                        }
                    }
                }
                
                if (canMove) camera.position.add(moveVec);
                
                const limit = MAP_SIZE/2 - 5;
                camera.position.x = Math.max(-limit, Math.min(limit, camera.position.x));
                camera.position.z = Math.max(-limit, Math.min(limit, camera.position.z));

                const gun = camera.userData.gun;
                if(gun) {
                    let targetPos = isReloading ? camera.userData.reloadPos : (isAiming ? camera.userData.aimPos : camera.userData.hipPos);
                    gun.position.lerp(targetPos, delta * 10); 
                    const ch = document.getElementById('crosshair');
                    ch.style.opacity = isAiming ? 0.3 : 1.0;
                }

                enemies.forEach(enemy => {
                    enemy.lookAt(camera.position.x, 1.3, camera.position.z);
                    const dist = enemy.position.distanceTo(camera.position);
                    const spd = enemy.userData.isBoss ? (ENEMY_BASE_SPEED * BOSS_SPEED_MULT) : ENEMY_BASE_SPEED;
                    
                    if (dist > 1.2) {
                        enemy.translateZ(spd * delta);
                        
                        // Walking Animation (Leg swing)
                        const walkSpeed = 10;
                        const legAmp = 0.5;
                        
                        // Access groups to rotate hip
                        const lLegGroup = enemy.getObjectByName("leftLegGroup");
                        const rLegGroup = enemy.getObjectByName("rightLegGroup");
                        
                        if (lLegGroup && rLegGroup) {
                            lLegGroup.rotation.x = Math.sin(time * walkSpeed + enemy.userData.id) * legAmp;
                            rLegGroup.rotation.x = Math.sin(time * walkSpeed + enemy.userData.id + Math.PI) * legAmp;
                        }

                    } else {
                        const baseDmg = enemy.userData.isBoss ? 30 : 10;
                        takeDamage(baseDmg * ENEMY_DAMAGE_MULT);
                    }
                });

                for (let i = ammoBoxes.length - 1; i >= 0; i--) {
                    const box = ammoBoxes[i];
                    box.rotation.y += delta;
                    if (box.position.distanceTo(camera.position) < 2.5) {
                        reserveAmmo += AMMO_PER_BOX; 
                        updateHUD();
                        scene.remove(box);
                        ammoBoxes.splice(i, 1);
                    }
                }
                for (let i = healthSticks.length - 1; i >= 0; i--) {
                    const stick = healthSticks[i];
                    stick.rotation.y += delta;
                    if (stick.position.distanceTo(camera.position) < 3.0) { 
                        if (health < 100) {
                            health = Math.min(100, health + 10);
                            updateHealthUI();
                        }
                        scene.remove(stick);
                        healthSticks.splice(i, 1);
                    }
                }
                birds.forEach(bird => {
                    bird.userData.angle += bird.userData.speed * delta;
                    bird.position.x += Math.sin(bird.userData.angle) * 0.1;
                    bird.position.z += Math.cos(bird.userData.angle) * 0.1;
                    bird.lookAt(bird.position.x + Math.sin(bird.userData.angle), bird.position.y, bird.position.z + Math.cos(bird.userData.angle));
                });
                prevTime = time;
            } else {
                prevTime = performance.now(); 
            }
            renderer.render(scene, camera);
        }
        document.body.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body && !isDead) {
                camera.rotation.y -= event.movementX * 0.002;
                camera.rotation.x -= event.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        });
    </script>
</body>
</html>